```Haskell
fromY :: (a -> x) -> b -> x
fromY f b = f (btoa b)
```
```swift
protocol FunctionK {
  associatedtype F
  associatedtype G
  func invoke<A>(_ fa : Kind<F, A>) -> Kind<G, A>
}

class FromY<A, B> : FunctionK {
  typealias F = Kind<ForReader, A>
  typealias G = Kind<ForReader, B>

  func invoke<C>(_ fc : Kind2<ForReader, A, C>) -> Kind<ForReader<B, C>> {
    let fixed = Reader<A, C>.fix(fc)
    return Reader<B, C>({ b in fixed.f(btoa(b)) })
  }
}

def fromY[A, B]: (A => ?) ~> (B => ?) =
  new ~>[A => ?, B => ?] {
    def apply[X](f: A => X): B => X =
      b => f(btoa(b))
  }
```
................
```Haskell
fromY id :: b -> a
```
```swift
FromY().invoke(Reader(id)) // : (B) -> A
```

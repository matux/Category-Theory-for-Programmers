```Haskell
type Reader a x = a -> x
```
```swift
class Reader<A, X> : Kind2<ForReader, A, X> {
  let f : (A) -> X
}
```
................
```Haskell
instance Functor (Reader a) where
    fmap f h = f . h
```
```swift
class ReaderFunctor<R> : Functor {
  typealias F = Kind<ForReader, R>
   func map<A, B>(_ fa : Kind2<ForReader, R, A>, _ f : @escaping (A) -> B) -> Kind2<ForReader, R, A> {
    let fixed = Reader<R, A>.fix(fa)
    return Reader<R, B>(compose(f, fixed.f))
  }
}
```
................
```Haskell
alpha :: forall x . (a -> x) -> F x
```
```swift
protocol FunctionK {
  associatedtype F
  associatedtype G
  func invoke<A>(_ fa : Kind<F, A>) -> Kind<G, A>
}

func alpha<A, F, FuncK>() -> FuncK where
  FuncK : FunctionK,
  FuncK.F == Kind<ForReader, A>,
  FuncK.G == F
```
................
```Haskell
forall x . (a -> x) -> F x ≅ F a
```
```swift
class NaturalTransformation<F, G> : FunctionK {}
NaturalTransformation<Kind<ForReader, A>, F> ≅ Kind<F, A>
```
................
```Haskell
alpha :: forall x . (a -> x) -> F x
```
```swift
func alpha<A, F, FuncK>() -> FuncK where
  FuncK : FunctionK,
  FuncK.F == Kind<ForReader, A>,
  FuncK.G == F
```
................
```Haskell
alpha id :: F a
```
```swift
alpha().invoke(Reader(id)) -> Kind<F, A>
```
................
```Haskell
fa :: F a
```
```swift
let fa : Kind<F, A>
```
................
```Haskell
alpha h = fmap h fa
```
```swift
alpha().invoke(h) = functor.map(fa, h)
```
................
```Haskell
forall r . (a -> r) -> r ≅ a
```
```swift
((A) -> R) -> R ≅ A
```
................
```Haskell
forall x . (x -> a) -> F x ≅ F a
```
```swift
NaturalTransformation<Kind<ForOp, A>, F> ≅ Kind<F, A>
```

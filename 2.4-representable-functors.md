```Haskell
type Reader a x = a -> x
```
```swift
class Reader<A, X> : Kind2<ForReader, A, X> {
  let f : (A) -> X
}
```
................
```Haskell
instance Functor (Reader a) where
    fmap f h = f . h
```
```swift
class ReaderFunctor<R> : Functor {
  typealias F = Kind<ForReader, R>

  func map<A, B>(_ fa : Kind2<ForReader, R, A>, _ f : @escaping (A) -> B) -> Kind2<ForReader, R, A> {
    let fixed = Reader<R, A>.fix(fa)
    return Reader<R, B>(compose(f, fixed.f))
  }
}
```
................
```Haskell
type Op a x = x -> a
```
```swift
class Op<A, X> : Kind2<ForOp, A, X> {
  let f : (X) -> A
}
```
................
```Haskell
instance Contravariant (Op a) where
    contramap f h = h . f
```
```swift
class OpContravariant<R> : Contravariant {
  typealias F = Kind<ForOp, R>

  func contramap<A, B>(_ fa : Kind2<ForOp, R, A>, _ f : @escaping (B) -> A) -> Kind2<ForOp, R, B> {
    let fixed = Op<R, A>.fix(fa)
    return Op<R, B>(compose(fixed.f, f))
  }
}
```
................
```Haskell
instance Profunctor (->) where
  dimap ab cd bc = cd . bc . ab
  lmap = flip (.)
  rmap = (.)
```
```swift
class ReaderProfunctor : Profunctor {
  typealias P = ForReader

  func dimap<A, B, C, D>(_ fbc : Kind<ForReader, B, C>, _ ab : @escaping (A) -> B, _ cd : @escaping (C) -> D) -> Kind<ForReader, A, D> {
    let bc = Reader<B, C>.fix(fbc).f
    return Reader<A, D>(compose(compose(cd, bc), ab))
  }
}
```
................
```Haskell
alpha :: forall x. (a -> x) -> F x
```
```swift
protocol FunctionK {
  associatedtype F
  associatedtype G

  func invoke<A>(_ fa : Kind<F, A>) -> Kind<G, A>
}

func alpha<A, F, FuncK>() -> FuncK where
  FuncK : FunctionK,
  FuncK.F == Kind<ForReader, A>,
  FuncK.G == F
```
................
```Haskell
fmap f . alpha = alpha . fmap f
```
```swift
compose(functor.lift(f), alpha().invoke) ==
  compose(alpha().invoke, functor.lift(f))
```
................
```Haskell
fmap f (alpha h) = alpha (f . h)
```
```swift
functor.map(alpha(h), f) == alpha(compose(f, h))
```
................
```Haskell
beta :: forall x. F x -> (a -> x)
```
```swift
func beta<A, F, FuncK>() -> FuncK where
  FuncK : FunctionK,
  FuncK.F == F
  FuncK.G == Kind<ForReader, A>
```
................
```Haskell
alpha :: forall x. (Int -> x) -> [x]
alpha h = map h [12]
```
```swift
class ReaderToList<R> : FunctionK {
  typealias F = Kind<ForReader, R>
  typealias G = ForList

  func invoke<A>(_ fa : Kind2<ForReader, R, A>) -> Kind<ForList, A> {
    let fixed = Reader<R, A>.fix(fa)
    return List<Int>.functor().map(Cons(12, Nil<Int>()), fixed.f)
  }
}

func alpha<A>() -> ReaderToList<A> {
  return ReaderToList<A>()
}
```
................
```Haskell
map f (map h [12]) = map (f . h) [12]
```
```swift
functor.map(functor.map(Cons(12, Nil<Int>()), h), f) ==
  functor.map(Cons(12, Nil<Int>()), compose(f, h))
```
................
```Haskell
beta :: forall x. [x] -> (Int -> x)
```
```swift
func beta<FuncK>() -> FuncK where
  FuncK : FunctionK,
  FuncK.F == ForList,
  FuncK.G == Kind<ForReader, Int>
```
................
```Haskell
class Representable f where
   type Rep f :: *
   tabulate :: (Rep f -> x) -> f x
   index    :: f x -> Rep f -> x
```
```swift
protocol Representable<F> {
  associatedtype Rep

  func tabulate<X>(_ f : (Rep) -> X) -> Kind<F, X>
  func index<X>(_ fx : Kind<F, X>) -> (Rep) -> X
}
```
................
```Haskell
data Stream x = Cons x (Stream x)
```
```swift
class Stream<A> : Kind<ForStream, A> {
  let head : () -> A
  let tail : () -> Stream<A>

  static func fix(_ value : Kind<ForStream, A>) -> Stream<A> {
    return value as! Stream<A>
  }

  init(_ head : @escaping () -> A, _ tail : @escaping () -> Stream<A>) {
    self.head = head
    self.tail = tail
  }
}
```
................
```Haskell
instance Representable Stream where
    type Rep Stream = Integer
    tabulate f = Cons (f 0) (tabulate (f . (+1)))
    index (Cons b bs) n = if n == 0 then b else index bs (n - 1)
```
```swift
class StreamRepresentable<ForStream> : Representable {
  typealias Rep = Int

  func tabulate<X>(_ f : (Int) -> X) -> Kind<ForStream, X> {
    return Stream<X>({ f(0) }, { tabulate(compose(f, { x in x + 1 })) })
  }

  func index<X>(_ fx : Kind<ForStream, X>) -> (Int) -> X {
    let stream = Stream<X>.fix(fx)
      return { n in
        (n == 0) ? stream.head() : index(stream.tail())(n - 1)
      }
  }
}
```

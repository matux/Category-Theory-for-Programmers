```Haskell
f >=> g = join . fmap g . f
```
```swift
func andThen<A, B>(_ f : @escaping (A) -> Kind<F, B>, _ g : @escaping (B) -> Kind<F, C>) -> (A) -> Kind<F, C> {
  return compose(compose(flatten, lift(g)), f)
}
```
................
```Haskell
(f >=> g) a = join (fmap g (f a))
```
```swift
func andThen<A, B>(_ f : @escaping (A) -> Kind<F, B>, _ g : @escaping (B) -> Kind<F, C>) -> (A) -> Kind<F, C> {
  return { a in flatten(map(f(a), g)) }
}
```
................
```Haskell
class Monoid m where
    mappend :: m -> m -> m
    mempty  :: m
```
```swift
protocol Monoid {
  associatedtype M

  func mappend(_ a : M, _ b : M) -> M
  val mempty : M { get }
}
```
................
```Haskell
mappend :: m -> (m -> m)
```
```swift
func mappend(_ x : M) -> (M) -> M
```
................
```Haskell
mu :: (m, m) -> m
```
```swift
func mu(_ mm : (M, M)) -> M
```
................
```Haskell
eta :: () -> m
```
```swift
func eta() -> M
```
................
```Haskell
mu (x, mu (y, z)) = mu (mu (x, y), z)
```
```swift
mu(x, mu(y, z)) == mu(mu(x, y), z)
```
................
```Haskell
(mu . bimap id mu)(x, (y, z))
```
```swift
compose(mu, bimap(id, mu))
```
................
```Haskell
(mu . bimap mu id)((x, y), z)
```
```swift
compose(mu, bimap(mu, id))
```
................
```Haskell
mu . bimap id mu = mu . bimap mu id
```
```swift
compose(mu, bimap(id, mu)) == compose(mu, bimap(mu, id))
```
................
```Haskell
alpha :: ((a, b), c) -> (a, (b, c))
alpha ((x, y), z) = (x, (y, z))
```
```swift
func alpha<A, B, C>(_ v : ((A, B), C)) -> (A, (B, C)) {
  let ((a, b), c) = v
  return (a, (b, c))
}
```
................
```Haskell
mu . bimap id mu . alpha = mu . bimap mu id
```
```swift
compose(mu, compose(bimap(id, mu), alpha)) ==
  compose(mu, bimap(mu, id))
```
................
```Haskell
mu (eta (), x) = x
mu (x, eta ()) = x
```
```swift
mu(eta(), x) == x
mu(x, eta()) == x
```
................
```Haskell
(mu . bimap eta id) ((), x) = lambda ((), x)
(mu . bimap id eta) (x, ()) = rho (x, ())
```
```swift
compose(mu, bimap(eta, id))(((), x)) ==
  lambda(((), x))

compose(mu, bimap(id, eta))((x, ())) ==
  rho((x, ()))
```
................
```Haskell
lambda :: ((), a) -> a
lambda ((), x) = x
```
```swift
func lambda<A>(_ v : ((), A)) -> A {
  let (_, x) = v
  return x
}
```
................
```Haskell
rho :: (a, ()) -> a
rho (x, ()) = x
```
```swift
func rho<A>(_ v : (A, ())) -> A {
  let (x, _) = v
  return x
}
```
................
```Haskell
mu . bimap id eta = lambda
mu . bimap eta id = rho
```
```swift
compose(mu, bimap(eta, id)) == lambda
compose(mu, bimap(id, eta)) == rho
```
................
```Haskell
newtype State s a = State (s -> (a, s))
```
```swift
class State<S, A> : Kind2<ForState, S, A> {
  let f : (S) -> (A, S)
}
```
................
```Haskell
newtype Prod s a = Prod (a, s)
```
```swift
class Prod<S, A> : Kind2<ForProd, S, A> {
  let value : (S, A)
}
```
................
```Haskell
newtype Reader s a = Reader (s -> a)
```
```swift
class Reader<S, A> : Kind2<ForReader, S, A> {
  let f : (S) -> A
}
```
................
```Haskell
instance Adjunction (Prod s) (Reader s) where
  counit (Prod (Reader f, s)) = f s
  unit a = Reader (\s -> Prod (a, s))
```
```swift
class State<S> : Adjunction<Kind<ForProd, S>, Kind<ForReader, S>, ProdFunctor<S>, ReaderRepresentable<U>> {
  override func unit<A>(_ a : A) -> Kind2<ForReader, S, Kind2<ForProd, S, A>> {
    return Reader<S, Prod<S, A>>({ s in Prod((a, S)) })
  }

  override func counit<A>(_ a : Kind2<ForProd, S, Kind2<ForReader, S, A>>) -> A {
    let prod = Prod<S, Kind2<ForReader, S, A>>.fix(a)
    let reader = Reader<S, A>.fix(prod.value.0)
    return reader.f(prod.value.1)
  }
}
```
................
```Haskell
newtype State s a = State (s -> (a, s))
```
```swift
class State<S, A> : Kind2<ForState, S, A> {
  let f : (S) -> (A, S)
}
```
................
```Haskell
runState :: State s a -> s -> (a, s)
runState (State f) s = f s
```
```swift
func runState(_ state : State<S, A>, _ s : S) -> (A, S) {
  return state.f(s)
}
```
................
```Haskell
ssa :: State s (State s a)
runState ssa :: s -> (State s a, s)
```
```swift
func ssa<S, A>() -> State<S, State<S, A>>

func rss<S, A>() -> (S) -> (State<S, A>, S) {
  return runState(ssa).f
}
```
................
```Haskell
join :: State s (State s a) -> State s a
join ssa = State (uncurry runState . runState ssa)
```
```swift
func flatten<A>(_ ssa : State<S, State<S, A>>) -> State<S, A> {
  return State<S, A>(compose(uncurry(runState), runState(ssa).f))
}
```

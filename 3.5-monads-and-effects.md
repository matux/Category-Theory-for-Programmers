................
```Haskell
instance Monad [] where
    join = concat
    return x = [x]
```
```swift
class ListK<A> : Kind<ForListK, A> {
  let array : [A]

  static func fix(_ value : Kind<ForListK, A>) -> ListK<A> {
    return value as! ListK<A>
  }

  init(_ array : [A]) {
    self.array = array
  }
}

class ListKMonad : Monad {
  typealias F = ForListK

  func flatten<A>(_ ffa: Kind<ForListK, Kind<ForListK<A>>) -> Kind<ForListK<A>> {
    let list = ListK<A>.fix(ffa)
    return ListK<A>(list.array.reduce([]) { partial, next in partial + ListK<A>.fix(next).array } )
  }
}
```
................
```Haskell
as >>= k = concat (fmap k as)
```
```swift
func flatmap<A, B>(_ fa : Kind<ForListK, A>, _ f : @escaping (A) -> Kind<ForListK, B>) -> Kind<ForListK, B> {
  let fixed = ListK<A>.fix(fa)
  return flatten(map(fa, f))
}
```
................
```Haskell
guard :: Bool -> [()]
guard True  = [()]
guard False = []
```
```swift
func guard(_ b : Bool) -> ListK<()> {
  return b ? ListK([()]) : ListK([])
}
```
................
```Haskell
triples = do
    z <- [1..]
    x <- [1..z]
    y <- [x..z]
    guard (x^2 + y^2 == z^2)
    return (x, y, z)
```
```swift
// Assuming that we can create a lazy infinite list in Swift...
func triples() -> ListK<(Int, Int, Int)> {
  return ListK<Int>.monad().binding(
    {               ListK<Int>(1...) },
    { z          in ListK<Int>(1...z) },
    { z, x       in ListK<Int>(x...z) },
    { z, x, y    in guard(x * x + y * y == z * z) }
    { z, x, y, _ in ListK<(Int, Int, Int)>((x, y, z)) }
  )
}
```
................
```Haskell
triples = [(x, y, z) | z <- [1..]
                     , x <- [1..z]
                     , y <- [x..z]
                     , x^2 + y^2 == z^2]
```
```swift
// Assuming that we can create a lazy infinite list in Swift...
func triples() -> ListK<(Int, Int, Int)> {
  return ListK<Int>.monad().binding(
    {               ListK<Int>(1...) },
    { z          in ListK<Int>(1...z) },
    { z, x       in ListK<Int>(x...z) },
    { z, x, y    in guard(x * x + y * y == z * z) }
    { z, x, y, _ in ListK<(Int, Int, Int)>((x, y, z)) }
  )
}
```
................
```Haskell
newtype Reader e a = Reader (e -> a)
```
```swift
class Reader<E, A> : Kind2<ForReader, E, A> {
  let f : (E) -> A
}
```
................
```Haskell
runReader :: Reader e a -> e -> a
runReader (Reader f) e = f e
```
```swift
func runReader<E, A>(_ reader : Reader<E, A>, _ e : E) -> A {
  return reader.f(e)
}
```
................
```Haskell
ra >>= k = Reader (\e -> ...)
```
```swift
func flatmap<A, B>(_ fa : Kind2<ForReader, E, A>, _ f : @escaping (A) -> B) -> Kind2<ForReader, E, B> {
  return Reader<E, B>({ e in ... })
}
```
................
```Haskell
ra >>= k = Reader (\e -> let a = runReader ra e
                         in ...)
```
```swift
func flatmap<A, B>(_ fa : Kind2<ForReader, E, A>, _ f : @escaping (A) -> B) -> Kind2<ForReader, E, B> {
  return Reader<E, B>({ e in
    let a runReader(Reader<E, A>.fix(fa), e)
    ...
  })
}
```
................
```Haskell
ra >>= k = Reader (\e -> let a  = runReader ra e
                             rb = k a
                         in ...)
```
```swift
func flatmap<A, B>(_ fa : Kind2<ForReader, E, A>, _ f : @escaping (A) -> B) -> Kind2<ForReader, E, B> {
  return Reader<E, B>({ e in
    let a runReader(Reader<E, A>.fix(fa), e)
    let rb = f(a)
    ...
  })
}
```
................
```Haskell
ra >>= k = Reader (\e -> let a  = runReader ra e
                             rb = k a
                         in runReader rb e)
```
```swift
func flatmap<A, B>(_ fa : Kind2<ForReader, E, A>, _ f : @escaping (A) -> B) -> Kind2<ForReader, E, B> {
  return Reader<E, B>({ e in
    let a runReader(Reader<E, A>.fix(fa), e)
    let rb = f(a)
    return runReader(rb, e)
  })
}
```
................
```Haskell
instance Monad (Reader e) where
    ra >>= k = Reader (\e -> runReader (k (runReader ra e)) e)
    return x = Reader (\e -> x)
```
```swift
class ReaderMonad<E> : Monad {
  typealias F : Kind<ForReader, E>

  func flatmap<A, B>(_ fa : Kind2<ForReader, E, A>, _ f : @escaping (A) -> B) -> Kind2<ForReader, E, B> {
    return Reader<E, B>({ e in
      let a runReader(Reader<E, A>.fix(fa), e)
      let rb = f(a)
      return runReader(rb, e)
    })
  }

  func pure<A>(_ x : A) -> Kind2<ForReader, E, A> {
    return Reader<E, A>({ e in x })
  }
}
```
................
```Haskell
newtype Writer w a = Writer (a, w)
```
```swift
class Writer<W, A> : Kind2<ForWriter, W, A> {
  let w : (A, W)

  init(_ w : (A, W)) {
    self.w = w
  }
}
```
................
```Haskell
runWriter :: Writer w a -> (a, w)
runWriter (Writer (a, w)) = (a, w)
```
```swift
func runWriter<W, A>(_ writer : Writer<W, A>) -> (A, W) {
  return writer.w
}
```
................
```Haskell
instance (Monoid w) => Monad (Writer w) where
    (Writer (a, w)) >>= k = let (a', w') = runWriter (k a)
                            in Writer (a', w `mappend` w')
    return a = Writer (a, mempty)
```
```swift
class WriterMonoid<W, MonoidW> : Monad where MonoidW : Monoid, MonoidW.A == W {
  typealias F = Kind<ForWriter, W>

  let monoid : MonoidW

  init(monoid : MonoidW) {
    self.monoid = monoid
  }

  func flatmap<A, B>(_ fa : Kind2<ForWriter, W, A>, _ f : @escaping (A) -> Kind2<ForWriter, W, B>) -> Kind2<ForWriter, W, B> {
    let (a, w1) = runWriter(Writer<W, A>.fix(fa))
    let (b, w2) = runWriter(f(a))
    return Writer<W, B>((a, monoid.mappend(w1, w2)))
  }

  func pure<A>(_ a : A) -> Kind2<ForWriter, W, B> {
    return Writer<W, B>((a, monoid.mempty))
  }
}
```
................
```Haskell
newtype State s a = State (s -> (a, s))
```
```swift
class State<S, A> : Kind2<ForState, S, A> {
  let f : (S) -> (A, S)
}
```
................
```Haskell
runState :: State s a -> s -> (a, s)
runState (State f) s = f s
```
```swift
func runState<S, A>(_ state : State<S, A>) -> (S) -> (A, S) {
  return state.f
}
```
................
```Haskell
sa >>= k = State (\s -> let (a, s') = runState sa s
                            sb = k a
                        in runState sb s')
```
```swift
func flatmap<A, B>(_ fa : Kind2<ForState, S, A>, _ f : @escaping (A) -> Kind2<ForState, S, B>) -> Kind2<ForState, S, B> {
  return State<S, B>({ s in
    let (a, s1) = runState(State<S, A>.fix(fa))(s)
    let sb = State<S, B>.fix(f(a))
    return runState(sb)(s1)
  })
}
```
................
```Haskell
instance Monad (State s) where
    sa >>= k = State (\s -> let (a, s') = runState sa s
                            in runState (k a) s')
    return a = State (\s -> (a, s))
```
```swift
class StateMonad<S> : Monad {
  typealias F : Kind<ForState, S>

  func flatmap<A, B>(_ fa : Kind2<ForState, S, A>, _ f : @escaping (A) -> Kind2<ForState, S, B>) -> Kind2<ForState, S, B> {
    return State<S, B>({ s in
      let (a, s1) = runState(State<S, A>.fix(fa))(s)
      let sb = State<S, B>.fix(f(a))
      return runState(sb)(s1)
    })
  }

  func pure<A>(_ a : A) -> Kind2<ForState, S, A> {
    return State<S, A>({ s in (a, s) })
  }
}
```
................
```Haskell
get :: State s s
get = State (\s -> (s, s))
```
```swift
func get<S>() -> State<S, S> {
  return State<S, S>({ s in (s, s) })
}
```
................
```Haskell
put :: s -> State s ()
put s' = State (\s -> ((), s'))
```
```swift
func put<S>(_ s1 : S) -> State<S, ()> {
  return State<S, ()>({ _ in ((), s1) })
}
```
................
```Haskell
instance Monad Maybe where
    Nothing >>= k = Nothing
    Just a  >>= k = k a
    return a = Just a
```
```swift
class OptionMonad : Monad {
  typealias F = ForOption

  func flatmap<A, B>(_ fa : Kind<ForOption, A>, _ f : @escaping (A) -> Kind<ForOption, B>) -> Kind<ForOption, B> {
    switch(Option<A>.fix(fa)) {
      case is Some<A>:
        let some = (fa as! Some<A>).value
        return f(a)
      default: return None<B>()
    }
  }

  func pure<A>(_ a : A) -> Option<A> {
    return Some<A>(a)
  }
}
```
................
```Haskell
data Cont r a = Cont ((a -> r) -> r)
```
```swift
class Cont<R, A> : Kind2<ForCont, R, A> {
  let run : ((A) -> R) -> R

  static func fix(_ value : Kind2<ForCont, R, A>) -> Cont<R, A> {
    return value as! Cont<R, A>
  }

  init(_ run : @escaping ((A) -> R) -> R) {
    self.run = run
  }
}
```
................
```Haskell
runCont :: Cont r a -> (a -> r) -> r
runCont (Cont k) h = k h
```
```swift
func runCont<R, A>(_ cont : Cont<R, A>) -> ((A) -> R) -> R {
  return { h in cont.run(h) }
}
```
................
```Haskell
(>>=) :: ((a -> r) -> r) ->
         (a -> (b -> r) -> r) ->
         ((b -> r) -> r)
```
```swift
func flatmap<A, B>(_ fa : Kind2<ForCont, R, A>, _ f : @escaping (A) -> Kind2<ForCont, R, B>) -> Kind2<ForCont, R, B>

// Equivalent to:
// func flatmap<A, B>(_ fa : ((A) -> R) -> R, _ f : @escaping (A) -> (((B) -> R) -> R)) -> ((B) -> R) -> R
```
................
```Haskell
ka >>= kab = Cont (\hb -> ...)
```
```swift
func flatmap<A, B>(_ fa : Kind2<ForCont, R, A>, _ f : @escaping (A) -> Kind2<ForCont, R, B>) -> Kind2<ForCont, R, B> {
  return Cont<R, B>({ hb in
    ...
  })
}
```
................
```Haskell
runCont ka (\a -> ...)
```
```swift
runCont(ka) { a in ... }
```
................
```Haskell
runCont ka (\a -> let kb = kab a
                  in runCont kb hb)
```
```swift
runCont(ka) { a in
  let kb = Cont<R, B>.fix(f(a))
  runCont(kb)(hb)
}
```
................
```Haskell
instance Monad (Cont r) where
    ka >>= kab = Cont (\hb -> runCont ka (\a -> runCont (kab a) hb))
    return a = Cont (\ha -> ha a)
```
```swift
class ContMonad<R> : Monad {
  typealias F = Kind<ForCont, R>

  func flatmap<A, B>(_ fa : Kind2<ForCont, R, A>, _ f : @escaping (A) -> Kind2<ForCont, R, B>) -> Kind2<ForCont, R, B> {
    return Cont<R, B>({ hb in
      runCont(Cont<R, A>.fix(fa)) { a in
        let kb = Cont<R, B>.fix(f(a))
        return runCont(kb)(hb)
      }
    })
  }

  func pure<A>(_ a : A) -> Cont<R, A> {
    return Cont<R, A>({ ha in ha(a) })
  }
}
```
................
```Haskell
getChar :: () -> IO Char
```
```swift
func getChar() -> IO<Character>
```
................
```Haskell
main :: IO ()
```
```swift
func main() -> IO<()>
```
................
```Haskell
main :: () -> IO ()
```
```swift
let main : () -> IO<()>
```
................
```Haskell
type IO a  =  RealWorld -> (a, RealWorld)
```
```swift
typealias IO<A> = RealWorld -> (A, RealWorld)
```
................
```Haskell
type IO = State RealWorld
```
```swift
typealias IO<A> = State<RealWorld, A>
```
................
```Haskell
putStr :: String -> IO ()
```
```swift
func putStr(_ str : String) -> IO<()>
```
................
```Haskell
putStr :: String -> ()
```
```swift
let putStr : (String) -> ()
```
................
```Haskell
main :: IO ()
main = do
    putStr "Hello "
    putStr "World!"
```
```swift
func main() -> IO<()> {
  return IO<Any>.monad().binding(
    {      putStr("Hello ") }
    { _ in putStr("World!")}
  )
}
```

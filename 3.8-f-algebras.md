```Haskell
type Algebra f a = f a -> a
```
```scala
typealias Algebra<F, A> = (Kind<F, A>) -> A
```
................
```Haskell
data MonF a = MEmpty | MAppend a a
```
```swift
class MonF<A> : Kind<ForMonF, A> {}
class MEmpty<A> : MonF<A> {}
class MAppend<A> : MonF<A> {
  let m : A
  let n : A

  init(_ m : A, _ n : A) {
    self.m = m
    self.n = n
  }
}
```
................
```Haskell
data RingF a = RZero
             | ROne
             | RAdd a a
             | RMul a a
             | RNeg a
```
```swift
class RingF<A> : Kind<ForRingF, A> {}
class RZero<A> : RingF<A> {}
class ROne<A> : RingF<A> {}
class RAdd<A> : RingF<A> {
  let m : A
  let n : A

  init(_ m : A, _ n : A) {
    self.m = m
    self.n = n
  }
}
class RMul<A> : RingF<A> {
  let m : A
  let n : A

  init(_ m : A, _ n : A) {
    self.m = m
    self.n = n
  }
}
class RNeg<A> : RingF<A> {
  let n : A

  init(_ n : A) {
    self.n = n
  }
}
```
................
```Haskell
evalZ :: Algebra RingF Integer
evalZ RZero      = 0
evalZ ROne       = 1
evalZ (RAdd m n) = m + n
evalZ (RMul m n) = m * n
evalZ (RNeg n)   = -n
```
```swift
let evalZ : Algebra<ForRingF, Int> = { fa in
  switch(fa) {
    case is RZero<Int>: return 0
    case is ROne<Int>: return 1
    case is RAdd<Int>:
      let add = fa as! RAdd<Int>
      return add.m + add.n
    case is RMul<Int>:
      let mul = fa as! RMul<Int>
      return mul.m * mul.n
    default:
      let neg = fa as! RNeg<Int>
      return -neg.n
  }
}
```
................
```Haskell
data Expr = RZero
          | ROne
          | RAdd Expr Expr
          | RMul Expr Expr
          | RNeg Expr
```
```swift
enum Expr {
  case rZero
  case rOne
  case rAdd(Expr, Expr)
  case rMul(Expr, Expr)
  case rNeg(Expr)
}
```
................
```Haskell
evalZ :: Expr -> Integer
evalZ RZero        = 0
evalZ ROne         = 1
evalZ (RAdd e1 e2) = evalZ e1 + evalZ e2
evalZ (RMul e1 e2) = evalZ e1 * evalZ e2
evalZ (RNeg e)     = -(evalZ e)
```
```swift
func evalZ(_ expr : Expr) -> Int {
  switch(expr) {
    case .rZero: return 0
    case .rOne: return 1
    case let .rAdd(e1, e2): return evalZ(e1) + evalZ(e2)
    case let .rMul(e1, e2): return evalZ(e1) * evalZ(e2)
    case let .rNeg(e): return -evalZ(e)
  }
}
```
................
```Haskell
type RingF1 a = RingF (RingF a)
```
```swift
typealias RingF1<A> = RingF<RingF<A>>
```
................
```Haskell
type RingF2 a = RingF (RingF (RingF a))
```
```swift
typealias RingF2<A> = RingF<RingF<RingF<A>>>
```
................
```Haskell
type RingF2 a = RingF (RingF1 a)
```
```swift
typealias RingF2<A> = RingF<RingF1<A>>
```
................
```Haskell
type RingFn+1 a = RingF (RingFn a)
```
```swift
typealias RingFnplus1<A> = RingF<RingFn<A>>
```
................
```Haskell
newtype Fix f = Fix (f (Fix f))
```
```swift
class Fix<F> : FixOf<F> {
  let unFix : Kind<F, FixOf<F>>

  static func fix(_ value : FixOf<F>) -> Fix<F> {
    return value as! Fix<F>
  }

  init(unFix : Kind<F, FixOf<F>>) {
    self.unFix = unFix
  }
}
```
................
```Haskell
newtype Fix f = In (f (Fix f))
```
```swift
class Fix<F> : FixOf<F> {
  let unFix : Kind<F, FixOf<F>>

  static func fix(_ value : FixOf<F>) -> Fix<F> {
    return value as! Fix<F>
  }

  init(unFix : Kind<F, FixOf<F>>) {
    self.unFix = unFix
  }
}
```
................
```Haskell
Fix :: f (Fix f) -> Fix f
```
```swift
class Fix<F> : FixOf<F> {
  let unFix : Kind<F, FixOf<F>>

  static func fix(_ value : FixOf<F>) -> Fix<F> {
    return value as! Fix<F>
  }

  init(unFix : Kind<F, FixOf<F>>) {
    self.unFix = unFix
  }
}
```
................
```Haskell
unFix :: Fix f -> f (Fix f)
unFix (Fix x) = x
```
```swift
let fix : Fix<F> = ...
fix.unfix
```
................
```Haskell
data NatF a = ZeroF | SuccF a
```
```swift
class NatF<A> : Kind<ForNatF, A> {}
class ZeroF<A> : NatF<A> {}
class SuccF<A> : NatF<A> {
  let a : A

  init(_ a : A) {
    self.a = a
  }
}
```
................
```Haskell
data Nat = Zero | Succ Nat
```
```swift
enum Nat {
  case zero
  case succ(Nat)
}
```
................
```Haskell
cata :: Functor f => (f a -> a) -> Fix f -> a
cata alg = alg . fmap (cata alg) . unFix
```
```swift
func cata<F, A, FunctorF>(_ alg : (Kind<F, A>) -> A, _ functor : FunctorF) -> (Fix<F>) -> A where
  FunctorF : Functor, FunctorF.F == F {
  compose(compose(alg, functor.lift(cata(alg, functor))), alg.unFix)
}
```
................
```Haskell
data NatF a = ZeroF | SuccF a
```
```swift
class NatF<A> : Kind<ForNatF, A> {}
class ZeroF<A> : NatF<A> {}
class SuccF<A> : NatF<A> {
  let a : A

  init(_ a : A) {
    self.a = a
  }
}
```
................
```Haskell
fib :: NatF (Int, Int) -> (Int, Int)
fib ZeroF = (1, 1)
fib (SuccF (m, n)) = (n, m + n)
```
```swift
let fib : NatF<(Int, Int)> -> (Int, Int) = { fa in
  switch(fa) {
    case is SuccF<(Int, Int)>:
      let succ = fa as! SuccF<(Int, Int)>
      return (succ.a.1, succ.a.0 + succ.a.1)
    default: return (1, 1)
  }
}
```
................
```Haskell
data ListF e a = NilF | ConsF e a
```
```swift
class ListF<E, A> : Kind2<ForListF, E, A> {}
class NilF<E, A> : ListF<E, A> {}
class ConsF<E, A> : ListF<E, A> {
  let head : E
  let tail : A

  init(_ head : E, _ tail : A) {
    self.head = head
    self.tail = tail
  }
}
```
................
```Haskell
data List e = Nil | Cons e (List e)
```
```swift
enum List<E> {
  case `nil`
  case cons(E, List<E>)
}
```
................
```Haskell
lenAlg :: ListF e Int -> Int
lenAlg (ConsF e n) = n + 1
lenAlg NilF = 0
```
```swift
func lenAlg<E>(_ list : ListF<E, Int>) -> Int {
  switch(list) {
    case is ConsF<E, Int>:
      let cons = list as! ConsF<E, Int>
      return cons.tail + 1
    default: return 0
  }
}
```
................
```Haskell
length = foldr (\e n -> n + 1) 0
```
```swift
func length<E>(_ array : [E]) -> Int {
  return array.reduce(0) { partial, _ in partial + 1 }
}
```
................
```Haskell
sumAlg :: ListF Double Double -> Double
sumAlg (ConsF e s) = e + s
sumAlg NilF = 0.0
```
```swift
let sumAlg : (ListF<Double, Double>) -> Double { fa in
  switch(fa) {
    case is Cons<Double, Double>:
      let cons = fa as! Cons<Double, Double>
      return cons.head + cons.tail
    default: return 0.0
  }
}
```
................
```Haskell
sum = foldr (\e s -> e + s) 0.0
```
```swift
func sum(_ array : [Double]) -> Double {
  return array.reduce(0.0) { partial, next in partial + next }
}
```
................
```Haskell
ana :: Functor f => (a -> f a) -> a -> Fix f
ana coalg = Fix . fmap (ana coalg) . coalg
```
```swift
func ana<F, A, FunctorF>(_ coalg : @escaping (A) -> Kind<F, A>, _ functor : FunctorF) -> (A) -> Fix<F> where
  FunctorF : Functor, FunctorF.F == F {
  return compose(compose(Fix<F>.init, funtor.lift(ana(coalg, functor))), coalg)
}
```
................
```Haskell
data StreamF e a = StreamF e a
  deriving Functor
```
```swift
class StreamF<E, A> : Kind2<ForStreamF, E, A> {
  let head : E
  let tail : A

  init(_ head : E, _ tail : A) {
    self.head = head
    self.tail = tail
  }
}
```
................
```Haskell
data Stream e = Stream e (Stream e)
```
```swift
class Stream<E> : Kind<ForStream, E> {
  let head : E
  let tail : Stream<E>

  init(head : E, tail : Stream<E>) {
    self.head = head
    self.tail = tail
  }
}
```
................
```Haskell
era :: [Int] -> StreamF Int [Int]
era (p : ns) = StreamF p (filter (notdiv p) ns)
    where notdiv p n = n `mod` p /= 0
```
```swift
func era(_ array : [Int]) -> StreamF<Int, [Int]> {
  func notdiv(_ p : Int, _ n : Int) -> Bool {
    return n % p != 0
  }
  let head = array[0]
  let tail = Array(array[1..])
  return StreamF<Int, [Int]>(head, tail.filter { x in notdiv(head, x) })
}
```
................
```Haskell
primes = ana era [2..]
```
```swift
// Assuming we can make an infinite array
let primes = ana(era([2..]), StreamF<Int, [Int]>.functor())
```
................
```Haskell
toListC :: Fix (StreamF e) -> [e]
toListC = cata al
   where al :: StreamF e [e] -> [e]
         al (StreamF e a) = e : a
```
```swift
func toListC<E>(_ fix : Fix<Kind<StreamF, E>) -> [E] {
  let al = { fa in
    let stream = Stream<E, [E]>.fix(fa)
    return [stream.head] + stream.tail
  }
  return cata(al, StreamF<E, [E]>.functor())
}
```
................
```Haskell
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
```
```swift
func unfoldr<A, B>(_ f : @escaping (B) -> Option<(A, B)>, _ b : B) -> [A]
```
................
```Haskell
set :: a -> s -> a
get :: a -> s
```
```swift
func set<A, S>(_ a : A, _ s : S) -> A
func get<A, S>(_ a : A) -> S
```
................
```Haskell
a -> (s, s -> a)
```
```swift
(A) -> (S, (S) -> A)
```
................
```Haskell
a -> Store s a
```
```swift
(A) -> Store<S, A>
```
................
```Haskell
data Store s a = Store (s -> a) s
```
```swift
class Store<S, A> : Kind2<ForStore, S, A> {
  let run : (S) -> A
  let s : S

  init(_ run : @escaping (S) -> A, _ s : S) {
    self.run = run
    self.s = s
  }
}
```

```Haskell
alphaₐ :: F a -> G a
```
```swift
func alphaA<F, G, A>(_ fa : Kind<F, A>) -> Kind<G, A>
```
................
```Haskell
alpha :: forall a . F a -> G a
```
```swift
func alphaA<F, G, A>(_ fa : Kind<F, A>) -> Kind<G, A>
```
................
```Haskell
alpha :: F a -> G a
```
```swift
func alphaA<F, G, A>(_ fa : Kind<F, A>) -> Kind<G, A>
```
................
```Haskell
alpha :: F a -> G a
```
```swift
func alphaA<F, G, A>(_ fa : Kind<F, A>) -> Kind<G, A>
```
................
```Haskell
safeHead :: [a] -> Maybe a
safeHead [] = Nothing
safeHead (x:xs) = Just x
```
```swift
func safeHead<A>(_ list : List<A>) -> Option<A> {
  switch(list) {
    case is Cons<A>:
      let cons = list as! Cons<A>
      return Some<A>(cons.head)
    default: return None<A>()
  }
}
```
................
```Haskell
fmap f . safeHead = safeHead . fmap f
```
```swift
compose(Option<Any>.functor().lift(f), safeHead) ==
  compose(safeHead, List<Any>.functor().lift(f))
```
................
```Haskell
fmap f (safeHead []) = fmap f Nothing = Nothing
```
```swift
Option<Any>.functor().lift(f)(safeHead(List<Any>.empty())) ==
  Option<Any>.functor().lift(f)(None()) == None()
```
................
```Haskell
safeHead (fmap f []) = safeHead [] = Nothing
```
```swift
safeHead(List<Any>.functor().lift(f)(List<Any>.empty())) ==
  safeHead(List<Any>.empty()) == None()
```
................
```Haskell
fmap f (safeHead (x:xs)) = fmap f (Just x) = Just (f x)
```
```swift
Option<Any>.functor().lift(f)(safeHead(Cons(x, xs))) ==
  Option<Any>.functor().lift(f)(Some(x)) == Some(f(x))
```
................
```Haskell
safeHead (fmap f (x:xs)) = safeHead (f x : fmap f xs) = Just (f x)
```
```swift
safeHead(List<Any>.functor().lift(f)(Cons(x, xs))) ==
  safeHead(Cons(f(x), List<Any>.functor().lift(f)(xs))) == Some(f(x))
```
................
```Haskell
fmap f [] = []
fmap f (x:xs) = f x : fmap f xs
```
```swift
func lift<A, B>(_ f : @escaping (A) -> B) -> (List<A>) -> List<B> {
  return { list in List<A>.functor().map(list, f) }
}
```
................
```Haskell
fmap f Nothing = Nothing
fmap f (Just x) = Just (f x)
```
```swift
func lift<A, B>(_ f : @escaping (A) -> B) -> (Option<A>) -> Option<B> {
  return { option in Option<A>.functor().map(option, f) }
}
```
................
```Haskell
length :: [a] -> Const Int a
length [] = Const 0
length (x:xs) = Const (1 + unConst (length xs))
```
```swift
func length<A>(_ list : List<A>) -> Const<Int, A> {
  switch(list) {
    case is Cons<A>:
      let cons = list as! Cons<A>
      return Const<Int, A>(1 + unConst(length(cons.tail)))
    default: return Const<Int, A>(0)
  }
}
```
................
```Haskell
unConst :: Const c a -> c
unConst (Const x) = x
```
```swift
func unConst<C, A>(_ x : Const<C, A>) -> C {
  return x.c
}
```
................
```Haskell
length :: [a] -> Int
```
```swift
func length<A>(_ list : List<A>) -> Int
```
................
```Haskell
scam :: Const Int a -> Maybe a
scam (Const x) = Nothing
```
```swift
func scam<A>(_ x : Const<Int, A>) -> Option<A> {
  return None<A>()
}
```
................
```Haskell
newtype Reader e a = Reader (e -> a)
```
```swift
class Reader<E, A> : Kind2<ForReader, E, A> {
  let f : (E) -> A

  static func fix(_ value : Kind<ForReader, E, A>) -> Reader<E, A> {
    return value as! Reader<E, A>
  }

  init(_ f : @escaping (E) -> A) {
    self.f = f
  }
}
```
................
```Haskell
instance Functor (Reader e) where
    fmap f (Reader g) = Reader (\x -> f (g x))
```
```swift
typealias ReaderPartial<E> = Kind<ForReader, E>

class ReaderFunctor<E> : Functor {
  typealias F = ReaderPartial<E>

  func map<A, B>(_ fa : Kind2<ForReader, E, A>, _ f : @escaping (A) -> B) -> Kind2<ForReader, E, B> {
    let fixed = Reader<E, A>.fix(fa)
    return Reader<E, B>({ x in f(fixed.f(x)) })
  }
}
```
................
```Haskell
alpha :: Reader () a -> Maybe a
```
```swift
func alpha<A>(_ reader : Reader<(), A>) -> Maybe<A>
```
................
```Haskell
dumb (Reader _) = Nothing
```
```swift
func dumb<A>(_ reader : Reader<(), A>) -> Option<A> {
  return None<A>()
}
```
................
```Haskell
obvious (Reader g) = Just (g ())
```
```swift
func obvious(_ reader : Reader<(), A>) -> Option<A> {
  return Some<A>(g(()))
}
```
................
```Haskell
newtype Op r a = Op (a -> r)
```
```swift
class Op<R, A> : Kind2<ForOp, R, A> {
  let f : (A) -> R

  static func fix(_ value : Kind2<ForOp, R, A>) -> Op<R, A> {
    return value as! Op<R, A>
  }

  init(_ f : @escaping (A) -> R) {
    self.f = f
  }
}
```
................
```Haskell
instance Contravariant (Op r) where
    contramap f (Op g) = Op (g . f)
```
```swift
class OpContravariant<R> : Contravariant {
  typealias F = Kind<ForOp, R>

  func contramap<A, B>(_ fa : Kind2<ForOp, R, A>, _ f : @escaping (B) -> A) -> Kind2<ForOp, R, B> {
    let fixed = Op<R, A>.fix(fa)
    return Op<R, B>(compose(fixed.f, f)
  }
}
```
................
```Haskell
predToStr (Op f) = Op (\x -> if f x then "T" else "F")
```
```swift
func predToStr<A>(_ op : Op<Bool, A>) -> Op<String, A> {
  return Op<String, A>({ x in op.f(x) ? "T" : "F"  })
}
```
................
```Haskell
contramap f . predToStr = predToStr . contramap f
```
```swift
compose({ fa in Op<String, A>.contravariant().contramap(fa, f) }, predToStr) ==
  compose(predToStr, { fa in Option<Bool, A>.contravariant().contramap(fa, f) })
```
................
```Haskell
contramap :: (b -> a) -> (Op Bool a -> Op Bool b)
```
```swift
class OpContravariant<R> : Contravariant {
  typealias F = Kind<ForOp, R>

  func contramap<A, B>(_ fa : Kind2<ForOp, R, A>, _ f : @escaping (B) -> A) -> Kind2<ForOp, R, B> {
    let fixed = Op<R, A>.fix(fa)
    return Op<R, B>(compose(fixed.f, f)
  }
}
```
................
```Haskell
a -> a
```
```swift
(A) -> A
```
................
```Haskell
(a -> a) -> f a
```
```swift
((A) -> A) -> Kind<F, A>
```

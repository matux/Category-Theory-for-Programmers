```Haskell
absurd :: Void -> a
```
```swift
func absurd<A>(_ x : Never) -> A
```
................
```Haskell
unit :: a -> ()
unit _ = ()
```
```swift
func unit<A>(_ a : A) -> () {
  return
}
```
................
```Haskell
yes :: a -> Bool
yes _ = True
```
```swift
func yes<A>(_ a : A) -> Bool {
  return true
}
```
................
```Haskell
no :: a -> Bool
no _ = False
```
```swift
func no<A>(_ a : A) -> Bool {
  return false
}
```
................
```Haskell
f . g = id
g . f = id
```
```swift
compose(f, g) == id
compose(g, f) == id
```
................
```Haskell
fst :: (a, b) -> a
fst (x, y) = x
```
```swift
func fst<A, B>(_ x : (A, B)) -> A {
  return x.0
}
```
................
```Haskell
snd :: (a, b) -> b
snd (x, y) = y
```
```kotlin:ank:silent
fun <A, B> snd(fa: Tuple2<A, B>): B {
  val (x, y) = fa
  return y
}
```
................
```Haskell
fst (x, _) = x
snd (_, y) = y
```
```swift
func fst<A, B>(_ x : (A, B)) -> A {
  return x.0
}

func snd<A, B>(_ x : (A, B)) -> B {
  return x.1
}
```
................
```Haskell
p :: c -> a
q :: c -> b
```
```swift
func p<C, A>(_ x : C) -> A
func q<C, B>(_ x : C) -> B
```
................
```Haskell
p :: Int -> Int
p x = x

q :: Int -> Bool
q _ = True
```
```swift
func p(_ n: Int) -> Int {
  return n
}

fun q(n: Int) -> Boolean {
  return true
}
```
................
```Haskell
p :: (Int, Int, Bool) -> Int
p (x, _, _) = x

q :: (Int, Int, Bool) -> Bool
q (_, _, b) = b
```
```swift
func p(_ t: (Int, Int, Bool)) -> Int {
  return t.0
}

func q(_ t: (Int, Int, Bool)) -> Int {
  return t.2
}
```
................
```Haskell
p' = p . m
q' = q . m
```
```swift
p2 == compose(p, m)
q2 == compose(q, m)
```
................
```Haskell
m :: Int -> (Int, Bool)
m x = (x, True)
```
```swift

func m(x: Int) -> (Int, Boolean) {
  return (x, true)
}
```
................
```Haskell
p x = fst (m x) = x
q x = snd (m x) = True
```
```swift
func p(_ x: Int) -> Int {
  return fst(m(x)) // == x
}

func q(_ x: Int) -> Bool {
  return snd(m(x)) // == true
}
```
................
```Haskell
m (x, _, b) = (x, b)
```
```swift
func m(_ fa: (Int, Int, Bool)) -> (Int, Bool) {
  let (x, _, b) = fa
  return (x, b)
}
```
................
```Haskell
fst = p . m'
snd = q . m'
```
```swift
fst == compose(p, m2)
snd == compose(p, m2)
```
................
```Haskell
m' (x, b) = (x, x, b)
```
```swift
func m2(_ fa: (Int, Bool)) -> (Int, Int, Bool) {
  let (x, b) = fa
  return (x, x, b)
}
```
................
```Haskell
m' (x, b) = (x, 42, b)
```
```swift
func m2(_ fa: (Int, Bool)) -> (Int, Int, Bool) {
  let (x, b) = fa
  return (x, 42, b)
}
```
................
```Haskell
m :: c -> (a, b)
m x = (p x, q x)
```
```swift
func m(_ x: Int) -> (Int, Bool) {
  return (p(x), q(x))
}
```
................
```Haskell
factorizer :: (c -> a) -> (c -> b) -> (c -> (a, b))
factorizer p q = \x -> (p x, q x)
```
```swift
func factorizer<A, B, C>(_ p: @escaping (C) -> A, _ q: @escaping (C) -> B) -> (C) -> (A, B) {
  return { x in (p(x), q(x)) }
}
```
................
```Haskell
i :: a -> c
j :: b -> c
```
```swift
func i<A, C>(_ a : A) -> C
func j<B, C>(_ b : B) -> C
```
................
```Haskell
i' = m . i
j' = m . j
```
```swift
i_prime == compose(m, i)
j_prime == compose(m, j)
```
................
```Haskell
data Contact = PhoneNum Int | EmailAddr String
```
```swift
enum Contact {
  case phoneNum(Int)
  case emailAddr(String)
}
```
................
```Haskell
helpdesk :: Contact;
helpdesk = PhoneNum 2222222
```
```swift
let helpdesk: Contact = .phoneNum(2222222)
```
................
```Haskell
Either a b = Left a | Right b
```
```swift
enum Either<A, B> {
  case left(A)
  case right(B)
}
```
................
```Haskell
factorizer :: (a -> c) -> (b -> c) -> Either a b -> c
factorizer i j (Left a)  = i a
factorizer i j (Right b) = j b
```
```swift
func factorizer<A, B, C>(_ i: @escaping (A) -> C, _ j : @escaping (B) -> C) -> (Either<A, B>) -> C {
  return { x in
    switch(x) {
      case let .left(a): return i(a)
      case let .right(b): return j(b)
    }
  }
}
```
................
```Haskell
p = fst . m
q = snd . m
```
```swift
p == compose(fst, m)
q == compose(snd, m)
```
................
```Haskell
p () = fst (m ())
q () = snd (m ())
```
```swift
p(()) == fst(m(()))
q(()) == snd(m(()))
```
